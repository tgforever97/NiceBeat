app {


  server {
    protocol = "http"
    host = "game.seekloud.org"
    port = 50443
    rootPath = "tank"
    InternalToken = "aklj345lkjOIu3df3fc45olnmadf"
  }

  http {
    interface = "0.0.0.0"
    port = 30369
  }

  tankGameRoomManager{
    personLimit = 100
    leftTimeLimit = 5
  }

  authCheck = false
  ramblerAuthCheck = false

  client {
    appIds = ["rambler","seagull","rookie","chaos","esheep","1000000002"]
    secureKeys = ["484ec7db9e39bc4b5e3d","3x4ecddb9f39bc4b5e3f","4fdfbtefbsn54jfdsv67","8v3fbtefaud54jxdsv67","2d3fbtefdwx4jxdssf4","kTpuLcildjisI5N7doM5WCjKXPDCZbTz"]
  }

  adminAccount = ["hong@test:123456","admin:legion123"]


  upperRainbowConf { //向上游节点获取数据
    isWork = true
    appId = "rainbow"
    secureKey = "i3248y1obo8wq*23HRO238RY(*E92Q8EY9*@3Y91283"
    host = "127.0.0.1"
    //    host = "10.1.29.250"

    port = "30363"

    eventFetcher{
      eachFetchNum = 200
      idleIntervalTime = 2
      busyIntervalTime = 2
    }

    userInfoFetcher{
      eachFetchNum = 100
      idleIntervalTime = 30
      busyIntervalTime = 5
    }
  }

  rambler {
    appId = "galaxy"
    secureKey = "sdjsai2D38f2f83hfsF"

    protocol = "http"
    //    host = "192.168.0.250"
    //        host = "10.1.29.250"

    host = "47.93.119.6"
    port = 30354
    domain = "flowdev.neoap.com"
    //    rootUrl = "/rambler2"
    rootUrl = "/rambler"
  }


  esheep{
    gameId = 1000000002
    gsKey = "kTpuLcildjisI5N7doM5WCjKXPDCZbTz"

    appId = "tank"
    secureKey = "sjdakhjskJHK7768G76sdksdkasHU"
    protocol = "http"
    // host = "10.1.29.250"
    host = "192.168.0.244"
    port = 30374
    domain = "flow.neoap.com"


    authToken = true

  }

  appBindSecureKey = "asdkdnfShdZxd324n4ax"


  gameRecordIsWork = true
  // gameDataDirectoryPath = "gameDataDirectoryPath/"
  gameRecordTime = 10 //min
  gameDataDirectoryPath = "/home/tank/product/tank/tankGameEssf/"


}

dependence {

  mpAuthor {
    protocol = "http"
    host = "192.168.0.249"
    //host = 10.1.29.249
    port = 30309
    appId = "444"
    secureKey = "ddd"
    componentAppId = "wxf6c8bd61d7086bf8"
    mpAppId = "wx0f9648452232479f"
  }


}


slick.db {
  //url = "jdbc:postgresql://10.1.29.250:5432/tank"
//  url = "jdbc:postgresql://192.168.0.250:5432/tank"
    url = "jdbc:postgresql://127.0.0.1:5432/tank"


  user = "tank"
  password = "tank1qaz@WSX"
  maximumPoolSize = 30
  connectTimeout = 30000
  idleTimeout = 300000
  maxLifetime = 900000
}




//akka.http{
//
//  session {
//    cookie {
//      name = "PLAY_SESSION"
//      domain = none
//      secure = false
//      http-only = true
//    }
//    server-secret = "0gfmOdf34doi2dg-aj53Kelk4;ztymc23;r3r3l*m3^20M3;l20;[+Gfdyrtyr4sKrtsyhf92dj:hf923"
//    max-age = none
//    encrypt-data = false
//  }
//
//  refresh-token {
//    cookie {
//      name = "PLAY_SESSION"
//      domain = none
//      secure = false
//      http-only = true
//    }
//
//    max-age = none
//    remove-used-token-after = 7200 seconds
//  }
//
//
//}

session {

  cookie {
    name = "galaxy"
    domain = none
    path = "/"
    secure = false
    httpOnly = true
    maxAge = 1 days
  }
  encryptData = false
  serverSecret = "dg-aj53Kei2+Gfhf92*md4sK3ymc23;rl4;zt3;lmOd4do3Dr^20M0;[0gfdytyrewr3lrtsy"

}


akka {
  loggers = ["akka.event.slf4j.Slf4jLogger"]
  loglevel = "DEBUG"
  logging-filter = "akka.event.slf4j.Slf4jLoggingFilter"

  http{
    server{
      websocket{
        periodic-keep-alive-max-idle = 1 second
      }
    }
  }

  # Used to set the behavior of the scheduler.
  # Changing the default values may change the system behavior drastically so make
  # sure you know what you're doing! See the Scheduler section of the Akka
  # Documentation for more details.
  scheduler {
    # The LightArrayRevolverScheduler is used as the default scheduler in the
    # system. It does not execute the scheduled tasks on exact time, but on every
    # tick, it will run everything that is (over)due. You can increase or decrease
    # the accuracy of the execution timing by specifying smaller or larger tick
    # duration. If you are scheduling a lot of tasks you should consider increasing
    # the ticks per wheel.
    # Note that it might take up to 1 tick to stop the Timer, so setting the
    # tick-duration to a high value will make shutting down the actor system
    # take longer.
    tick-duration = 1ms

    # The timer uses a circular wheel of buckets to store the timer tasks.
    # This should be set such that the majority of scheduled timeouts (for high
    # scheduling frequency) will be shorter than one rotation of the wheel
    # (ticks-per-wheel * ticks-duration)
    # THIS MUST BE A POWER OF TWO!
    ticks-per-wheel = 512

    # This setting selects the timer implementation which shall be loaded at
    # system start-up.
    # The class given here must implement the akka.actor.Scheduler interface
    # and offer a public constructor which takes three arguments:
    #  1) com.typesafe.config.Config
    #  2) akka.event.LoggingAdapter
    #  3) java.util.concurrent.ThreadFactory
    implementation = akka.actor.LightArrayRevolverScheduler

    # When shutting down the scheduler, there will typically be a thread which
    # needs to be stopped, and this timeout determines how long to wait for
    # that to happen. In case of timeout the shutdown of the actor system will
    # proceed without running possibly still enqueued tasks.
    shutdown-timeout = 5s
  }


  actor {

    warn-about-java-serializer-usage = off

    my-blocking-dispatcher {
      type = Dispatcher
      executor = "thread-pool-executor"

      thread-pool-executor {
        # Keep alive time for threads
        keep-alive-time = 60s

        # Define a fixed thread pool size with this property. The corePoolSize
        # and the maximumPoolSize of the ThreadPoolExecutor will be set to this
        # value, if it is defined. Then the other pool-size properties will not
        # be used.
        #
        # Valid values are: `off` or a positive integer.
        fixed-pool-size = off

        # Min number of threads to cap factor-based corePoolSize number to
        core-pool-size-min = 16

        # The core-pool-size-factor is used to determine corePoolSize of the
        # ThreadPoolExecutor using the following formula:
        # ceil(available processors * factor).
        # Resulting size is then bounded by the core-pool-size-min and
        # core-pool-size-max values.
        core-pool-size-factor = 100.0

        # Max number of threads to cap factor-based corePoolSize number to
        core-pool-size-max = 256

        # Minimum number of threads to cap factor-based maximumPoolSize number to
        max-pool-size-min = 16

        # The max-pool-size-factor is used to determine maximumPoolSize of the
        # ThreadPoolExecutor using the following formula:
        # ceil(available processors * factor)
        # The maximumPoolSize will not be less than corePoolSize.
        # It is only used if using a bounded task queue.
        max-pool-size-factor = 100.0

        # Max number of threads to cap factor-based maximumPoolSize number to
        max-pool-size-max = 256

        # Specifies the bounded capacity of the task queue (< 1 == unbounded)
        task-queue-size = -1

        # Specifies which type of task queue will be used, can be "array" or
        # "linked" (default)
        task-queue-type = "linked"

        # Allow core threads to time out
        allow-core-timeout = on
      }

      throughput = 100
    }

  }





}